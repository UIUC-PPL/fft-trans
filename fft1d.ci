mainmodule fft1d {

  mainchare Main {
    entry Main(CkArgMsg *m);
    entry [reductiontarget] void startTimer();
    entry [reductiontarget] void stopTimer();
    entry [reductiontarget] void startValidate();
    entry [reductiontarget] void validateDone();
    entry [reductiontarget] void doneSwap();
    entry [reductiontarget] void printResidual(double r);

    entry void validate() {
      serial {
        data.swap(CkCallback(CkReductionTarget(Main,doneSwap), thisProxy));
        fftProxy = CProxy_fft::ckNew(N, data, FFTW_BACKWARD, CkCallback(CkReductionTarget(Main,startValidate), thisProxy));
        TopoManager tmgr; // get dimensions for software routing
        int dims[4] = {tmgr.getDimNZ(), tmgr.getDimNY(), tmgr.getDimNX(), tmgr.getDimNT()};
        streamer = CProxy_GroupChunkMeshStreamer<fftw_complex>::ckNew(BUFSIZE, 4, dims, fftProxy);
      }

      when doneSwap(), startValidate() serial {
        fftProxy.doFFT(CkCallback(CkReductionTarget(Main,validateDone), thisProxy), streamer);
      }

      when validateDone() serial {
        data.calcResidual(CkCallback(CkReductionTarget(Main,printResidual), thisProxy));
      }

      when printResidual(double r) serial { CkPrintf("residual = %g\n", r); CkExit(); }
    };
  };

  group fftData {
    entry fftData(uint64_t N);
    entry void swap(CkCallback cb);
    entry void calcResidual(CkCallback cb);
  };

  group fft : MeshStreamerGroupClient<fftw_complex> {
    entry fft(uint64_t N, CProxy_fftData data, int sign, CkCallback startCB);
    entry void streamerReady();
    entry void receiveArray(fftw_complex data[numItems], int numItems, int src);
    entry void doneStreaming();

    entry void doFFT(CkCallback doneCB, CProxy_GroupChunkMeshStreamer<fftw_complex> streamer) {
      for(iteration = 0; iteration < 3; ++iteration) {
        serial {
          if(CkMyPe() == 0) CkPrintf("TRANSPOSING\n");
          initStreamer(streamer);
        }

        when streamerReady() serial { sendTranspose(iteration == 0 ? in : out); }

        for(count = 0; count < CkNumPes(); ++count)
          when receiveArray(fftw_complex data[numItems], int numItems, int src) serial {
            applyTranspose(data, numItems, src);
          }

        if (iteration < 2) serial {
          fftw_execute(p1);
          if(iteration == 0) twiddle(sign);
        }

        when doneStreaming() {}
      }

      serial { contribute(doneCB); }
    };
  };

  message MeshStreamerMessage<ChunkDataItem>;
  group MeshStreamerGroupClient<fftw_complex>;
  group GroupChunkMeshStreamer<fftw_complex>;
  group MeshStreamer<ChunkDataItem>;
};
